/**
 * This service client is auto-generated by Thrift2Ts.
 *
 * Tue Jul 04 2017 22:48:49 GMT+0800 (CST)
 */

import Thrift from "thrift-browser"
const {
    ThriftType,
    MessageType,
    TApplicationException,
    TException,
    IProtocol,
    ProtocolClass,
    ITransport,
    TransportClass
} = Thrift

import Request from "./request";

export const INT32CONSTANT: number = 9853; 

export const MAPCONSTANT: {[key: string]: string} = {"hello": "world", "goodnight": "moon"}; 

export enum Operation {
    ADD = 1,
    SUBTRACT = 2,
    MULTIPLY = 3,
    DIVIDE = 4
}

export class InvalidOperation extends TException {
    whatOp: number;
    why: string;
    name: string;

    constructor (args?) {
        super()
        this.name = "InvalidOperation"
        this.whatOp = null
        this.why = "abc"
        if (args) {
            if (args.whatOp !== undefined && args.whatOp !== null) {
                this.whatOp = args.whatOp
            }
            if (args.why !== undefined && args.why !== null) {
                this.why = args.why
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    if (ftype === ThriftType.I32) {
                        this.whatOp = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 2:
                    if (ftype === ThriftType.STRING) {
                        this.why = input.readString()
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('InvalidOperation')
        if (this.whatOp !== null && this.whatOp !== undefined) {
            output.writeFieldBegin('whatOp', ThriftType.I32, 1)
            output.writeI32(this.whatOp)
            output.writeFieldEnd()
        }
        if (this.why !== null && this.why !== undefined) {
            output.writeFieldBegin('why', ThriftType.STRING, 2)
            output.writeString(this.why)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Work {
    num1: number;
    num2: number;
    op: Operation;
    comment?: string;
    name: string;

    constructor (args?) {
        this.name = "Work"
        this.num1 = 0
        this.num2 = null
        this.op = null
        this.comment = null
        if (args) {
            if (args.num1 !== undefined && args.num1 !== null) {
                this.num1 = args.num1
            }
            if (args.num2 !== undefined && args.num2 !== null) {
                this.num2 = args.num2
            }
            if (args.op !== undefined && args.op !== null) {
                this.op = args.op
            }
            if (args.comment !== undefined && args.comment !== null) {
                this.comment = args.comment
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    if (ftype === ThriftType.I32) {
                        this.num1 = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 2:
                    if (ftype === ThriftType.I32) {
                        this.num2 = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 3:
                    if (ftype === ThriftType.I32) {
                        this.op = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 4:
                    if (ftype === ThriftType.STRING) {
                        this.comment = input.readString()
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Work')
        if (this.num1 !== null && this.num1 !== undefined) {
            output.writeFieldBegin('num1', ThriftType.I32, 1)
            output.writeI32(this.num1)
            output.writeFieldEnd()
        }
        if (this.num2 !== null && this.num2 !== undefined) {
            output.writeFieldBegin('num2', ThriftType.I32, 2)
            output.writeI32(this.num2)
            output.writeFieldEnd()
        }
        if (this.op !== null && this.op !== undefined) {
            output.writeFieldBegin('op', ThriftType.I32, 3)
            output.writeI32(this.op)
            output.writeFieldEnd()
        }
        if (this.comment !== null && this.comment !== undefined) {
            output.writeFieldBegin('comment', ThriftType.STRING, 4)
            output.writeString(this.comment)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_ping_args {
    name: string;

    constructor (args?) {
        this.name = "Calculator_ping_args"
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            input.skip(ftype)
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_ping_args')
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_ping_result {
    name: string;
    success: any;

    constructor (args?) {
        this.name = "Calculator_ping_result"
        this.success = null
        if (args) {
            if (args.success !== undefined && args.success !== null) {
                this.success = args.success
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    if (ftype === ThriftType.STRING) {
                        this.success = input.readString()
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_ping_result')
        if (this.success !== null && this.success !== undefined) {
            output.writeFieldBegin('success', ThriftType.STRING, 0)
            output.writeString(this.success)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_add_args {
    num1: number;
    num2?: number;
    name: string;

    constructor (args?) {
        this.name = "Calculator_add_args"
        this.num1 = null
        this.num2 = null
        if (args) {
            if (args.num1 !== undefined && args.num1 !== null) {
                this.num1 = args.num1
            }
            if (args.num2 !== undefined && args.num2 !== null) {
                this.num2 = args.num2
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    if (ftype === ThriftType.I32) {
                        this.num1 = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 2:
                    if (ftype === ThriftType.I32) {
                        this.num2 = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_add_args')
        if (this.num1 !== null && this.num1 !== undefined) {
            output.writeFieldBegin('num1', ThriftType.I32, 1)
            output.writeI32(this.num1)
            output.writeFieldEnd()
        }
        if (this.num2 !== null && this.num2 !== undefined) {
            output.writeFieldBegin('num2', ThriftType.I32, 2)
            output.writeI32(this.num2)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_add_result {
    name: string;
    success: any;

    constructor (args?) {
        this.name = "Calculator_add_result"
        this.success = null
        if (args) {
            if (args.success !== undefined && args.success !== null) {
                this.success = args.success
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    if (ftype === ThriftType.I32) {
                        this.success = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_add_result')
        if (this.success !== null && this.success !== undefined) {
            output.writeFieldBegin('success', ThriftType.I32, 0)
            output.writeI32(this.success)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_calculate_args {
    logid: number;
    w: Work;
    name: string;

    constructor (args?) {
        this.name = "Calculator_calculate_args"
        this.logid = null
        this.w = null
        if (args) {
            if (args.logid !== undefined && args.logid !== null) {
                this.logid = args.logid
            }
            if (args.w !== undefined && args.w !== null) {
                this.w = new Work(args.w)
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    if (ftype === ThriftType.I32) {
                        this.logid = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 2:
                    if (ftype === ThriftType.STRUCT) {
                        this.w = new Work()
                        this.w.read(input)
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_calculate_args')
        if (this.logid !== null && this.logid !== undefined) {
            output.writeFieldBegin('logid', ThriftType.I32, 1)
            output.writeI32(this.logid)
            output.writeFieldEnd()
        }
        if (this.w !== null && this.w !== undefined) {
            output.writeFieldBegin('w', ThriftType.STRUCT, 2)
            this.w.write(output)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_calculate_result {
    name: string;
    success: any;
    ouch: InvalidOperation;

    constructor (args?) {
        this.name = "Calculator_calculate_result"
        this.success = null
        this.ouch = null
        if (args instanceof InvalidOperation) {
            this.ouch = args
            return
        }
        if (args) {
            if (args.success !== undefined && args.success !== null) {
                this.success = args.success
            }
            if (args.ouch !== undefined && args.ouch !== null) {
                this.ouch = args.ouch
            }
        }
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    if (ftype === ThriftType.I32) {
                        this.success = input.readI32()
                    } else {
                        input.skip(ftype)
                    }
                    break
                case 1:
                    if (ftype === ThriftType.STRUCT) {
                        this.ouch = new InvalidOperation()
                        this.ouch.read(input)
                    } else {
                        input.skip(ftype)
                    }
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_calculate_result')
        if (this.success !== null && this.success !== undefined) {
            output.writeFieldBegin('success', ThriftType.I32, 0)
            output.writeI32(this.success)
            output.writeFieldEnd()
        }
        if (this.ouch !== null && this.ouch !== undefined) {
            output.writeFieldBegin('ouch', ThriftType.STRUCT, 1)
            this.ouch.write(output)
            output.writeFieldEnd()
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_zip_args {
    name: string;

    constructor (args?) {
        this.name = "Calculator_zip_args"
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            input.skip(ftype)
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_zip_args')
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class Calculator_zip_result {
    name: string;
    success: any;

    constructor (args?) {
        this.name = "Calculator_zip_result"
    }

    read = (input: IProtocol) => {
        input.readStructBegin()
        while (true) {
            let ret = input.readFieldBegin()
            let fname = ret.fname
            let ftype = ret.ftype
            let fid = ret.fid
            if (ftype === ThriftType.STOP) {
                break
            }
            input.skip(ftype)
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    write = (output: IProtocol) => {
        output.writeStructBegin('Calculator_zip_result')
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}

export class CalculatorClient {
    output: ITransport;
    pClass: ProtocolClass;
    id: number;
    reqs: { [key: string]: any }

    constructor (output: ITransport, pClass: ProtocolClass) {
        this.output = output
        this.pClass = pClass
        this.id = 0
        this.reqs = {}
    }

    ping = (callback) => {
        if (callback === undefined) {
            let self = this
            return new Promise(function (resolve, reject) {
                self.reqs[self.id] = (err, result) => {
                    if (err) {
                        reject(err)
                    } else {
                        resolve(result)
                    }
                }
                self.send_ping()
            })
        } else {
            this.reqs[this.id] = callback
            this.send_ping()
        }
    }

    send_ping = () => {
        let output = new this.pClass(this.output)
        output.writeMessageBegin('ping', MessageType.CALL, this.id)
        let args = new Calculator_ping_args()
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    recv_ping = (input, mtype, rseqid) => {
        let callback = this.reqs[rseqid] || function () { }
        delete this.reqs[rseqid]
        if (mtype === MessageType.EXCEPTION) {
        let x = new TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        let result = new Calculator_ping_result()
        result.read(input)
        input.readMessageEnd()

        if (null !== result.success) {
            return callback(null, result.success)
        }
        return callback('ping failed: unknown result')
    }

    add = (num1, num2, callback) => {
        if (callback === undefined) {
            let self = this
            return new Promise(function (resolve, reject) {
                self.reqs[self.id] = (err, result) => {
                    if (err) {
                        reject(err)
                    } else {
                        resolve(result)
                    }
                }
                self.send_add(num1, num2)
            })
        } else {
            this.reqs[this.id] = callback
            this.send_add(num1, num2)
        }
    }

    send_add = (num1, num2) => {
        let output = new this.pClass(this.output)
        output.writeMessageBegin('add', MessageType.CALL, this.id)
        let args = new Calculator_add_args(num1, num2)
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    recv_add = (input, mtype, rseqid) => {
        let callback = this.reqs[rseqid] || function () { }
        delete this.reqs[rseqid]
        if (mtype === MessageType.EXCEPTION) {
        let x = new TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        let result = new Calculator_add_result()
        result.read(input)
        input.readMessageEnd()

        if (null !== result.success) {
            return callback(null, result.success)
        }
        return callback('add failed: unknown result')
    }

    calculate = (logid, w, callback) => {
        if (callback === undefined) {
            let self = this
            return new Promise(function (resolve, reject) {
                self.reqs[self.id] = (err, result) => {
                    if (err) {
                        reject(err)
                    } else {
                        resolve(result)
                    }
                }
                self.send_calculate(logid, w)
            })
        } else {
            this.reqs[this.id] = callback
            this.send_calculate(logid, w)
        }
    }

    send_calculate = (logid, w) => {
        let output = new this.pClass(this.output)
        output.writeMessageBegin('calculate', MessageType.CALL, this.id)
        let args = new Calculator_calculate_args(logid, w)
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    recv_calculate = (input, mtype, rseqid) => {
        let callback = this.reqs[rseqid] || function () { }
        delete this.reqs[rseqid]
        if (mtype === MessageType.EXCEPTION) {
        let x = new TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        let result = new Calculator_calculate_result()
        result.read(input)
        input.readMessageEnd()

        if (null !== result.ouch) {
            throw result.ouch
        }
        if (null !== result.success) {
            return callback(null, result.success)
        }
        return callback('calculate failed: unknown result')
    }

    zip = (callback) => {
        if (callback === undefined) {
            let self = this
            return new Promise(function (resolve, reject) {
                self.reqs[self.id] = (err, result) => {
                    if (err) {
                        reject(err)
                    } else {
                        resolve(result)
                    }
                }
                self.send_zip()
            })
        } else {
            this.reqs[this.id] = callback
            this.send_zip()
        }
    }

    send_zip = () => {
        let output = new this.pClass(this.output)
        output.writeMessageBegin('zip', MessageType.CALL, this.id)
        let args = new Calculator_zip_args()
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }
}

export default {
    CalculatorClient
}
